1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

   ```java
   Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
   Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。
   ```

2. JDK和JRE的区别是什么？

   ```java
   JRE： Java Runtime Environment 
   JDK：Java Development Kit
   JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。
   JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。
   如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。
   JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本 
   再说说java的跨平台吧:
     java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行
   
   最后解释下机器码和字节码的区别:
    一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代码
   意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你给他个指令10001101，他们可能会解析为不同的结果～
   二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论那种硬件，只要你装有jvm,那么他就认识这个JAVA字节码～～～～至于底层的机器码，咱不用管，有jvm搞定，他会把字节码再翻译成所在机器认识的机器码～～～
   ```

3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？

   ```java
   “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
   Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
   java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。
   ```

4. 是否可以在static环境中访问非static变量？

   ```java
   static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。
   ```

5. Java支持的数据类型有哪些？什么是自动拆装箱？

   ```java
   Java语言支持的8种基本数据类型是：
   byte
   short
   int
   long
   float
   double
   boolean
   char
   自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。
   
   Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short, boolean ,int , long, float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程
   ```

6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？

   ```java
   Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。
   -------------------------------------------------------------------------
   方法重写的原则：
   
   重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型(从Java SE5开始支持)。
   重写方法不能比原方法访问性差（即访问权限不允许缩小）。
   重写方法不能比原方法抛出更多的异常。
   被重写的方法不能是final类型，因为final修饰的方法是无法重写的。
   被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。
   被重写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。
   重写是发生在运行时的，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。
       
   方法重载的原则：
   
   方法名称必须相同。
   参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。
   方法的返回类型可以相同也可以不相同。
   仅仅返回类型不同不足以成为方法的重载。
   重载是发生在编译时的，因为编译器可以根据参数的类型来选择使用哪个方法。
   重写和重载的不同：
   
   方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。
   方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。
   方法重写只能用于子类重写父类的方法，方法重载用于同一个类中的所有方法。
   方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。
   父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。
   重载是编译时多态，重写是运行时多态。
   ```

7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？

   ```JAVA
   当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。
   Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。
   Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。
   --------------------------------------------------------------------
   Java中的构造函数是为了初始化对象的，构造函数的函数名和类名一致，默认的构造函数没有参数，没有返回值，构造函数的函数体内，没有内容。 构造函数的重载是函数名与类名相同，参数类型不同，参数不同。同样的作用也是为了初始化对象的。 Java中没有拷贝构造函数的概念！
   ---------------------------------------------------------------------
   关于复制构造函数：C++中的复制构造函数通常有三种作用
   1.对象作为函数参数
   2.对象作为函数返回值
   3.使用一个对象对另一个对象初始化。
   C++语法允许用户定义自己的复制构造函数以实现自定义的复制，比如说进行深复制。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现。而且通过以上三种方式对Java对象进行的操作都是对引用的操作，不像C++里面是对原对象的操作，因此Java中也不需要考虑需要使用复制构造函数这种问题。
   ```

8. Java支持多继承么？

   ```JAVA
   Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。
   ```

9. 接口和抽象类的区别是什么？

   ```JAVA
   	接口和抽象类的区别: 1、定义接口的关键字是interface ，抽象类的关键字是abstract class 2、接口中的方法都是抽象的，抽象类中可以有方法的实现（即非抽象方法） 3、一个类可以实现多个接口，但只能继承一个抽象类，所以一般来说，可以使用接口实现的尽量使用接口实现。比如Runnable就比Thread使用频率高的多 4、接口和抽象类中都可以定义变量，但是接口中定义的必须是公共的、静态的、Final的，抽象类中的变量跟普通类中的没有区别。 5、抽象类可以包含静态方法，但是接口中不可以！ 6、接口中的方法必须是public的，抽象类中的方法可以使public 和 protected的 7、从设计上来说，接口是对一系列行为的抽象，而抽象类是对事物的抽象。 
       两者相同点: 1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 2.抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类还只能是抽象类。同样，一个类实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 
       两者不同点 : 什么时候使用抽象类和接口？ 1.如果有一些需要默认实现的方法并且要求子类重写，那么使用抽象类。 2.如果想实现多重继承，那么必须使用接口 3.如果基本功能在不断改变，那么就需要使用抽象类
   -------------------------------------------------------------------------
   1.接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法
   2.接口中的实例变量默认是final类型的，而抽象类中则不一定
   3.一个类可以实现多个接口，但最多只能实现一个抽象类
   4.一个类实现接口的话要实现接口的所有方法，而抽象类不一定
   5.接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象
   ```

10. 进程和线程的区别是什么？

    ```JAVA
    进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
    线程与进程的区别归纳：
    
    a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
    b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
    c.调度和切换：线程上下文切换比进程上下文切换要快得多。
    d.在多线程OS中，进程不是一个可执行的实体。
    ------------------------------------------------------------------------
    进程是运行中的程序，线程是进程的内部的一个执行序列
    进程是资源分配的单元，线程是执行行单元
    进程间切换代价大，线程间切换代价小
    进程拥有资源多，线程拥有资源少
    多个线程共享进程的资源
    ```

11. 创建线程有几种不同的方式？你喜欢哪一种？为什么？

    ```JAVA
    ①继承Thread类（真正意义上的线程类），是Runnable接口的实现。
    ②实现Runnable接口，并重写里面的run方法。
    ③使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现。
    
    调用线程的start()：启动此线程；调用相应的run()方法
    
    继承于Thread类的线程类，可以直接调用start方法启动线程（使用static也可以实现资源共享）.一个线程（对象）只能够执行一次start()，而且不能通过Thread实现类对象的run()去启动一个线程。
    
    实现Runnable接口的类需要再次用Thread类包装后才能调用start方法。（三个Thread对象包装一个类对象，就实现了资源共享）。
    线程的使用的话，注意锁和同步的使用。（多线程访问共享资源容易出现线程安全问题）
    
    一般情况下，常见的是第二种。
    
    * Runnable接口有如下好处：
    
    *①避免点继承的局限，一个类可以继承多个接口。
    
    *②适合于资源的共享
    
    /*
     * Thread的常用方法：
     * 1.start()：启动线程并执行相应的run()方法
     * 2.run():子线程要执行的代码放入run()方法中
     * 3.currentThread()：静态的，调取当前的线程
     * 4.getName():获取此线程的名字
     * 5.setName():设置此线程的名字
     * 6.yield():调用此方法的线程释放当前CPU的执行权（很可能自己再次抢到资源）
     * 7.join():在A线程中调用B线程的join()方法，表示：当执行到此方法，A线程停止执行，直至B线程执行完毕，
     * A线程再接着join()之后的代码执行
     * 8.isAlive():判断当前线程是否还存活
     * 9.sleep(long l):显式的让当前线程睡眠l毫秒  (只能捕获异常，因为父类run方法没有抛异常)
     * 10.线程通信（方法在Object类中）：wait()   notify()  notifyAll()
     *
     *设置线程的优先级（非绝对，只是相对几率大些）
     * getPriority()：返回线程优先值
     * setPriority(int newPriority)：改变线程的优先级
     */
    ```

12. 概括的解释下线程的几种可用状态。

    ```JAVA
    1. 新建(new)：新创建了一个线程对象。
    2. 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的 start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。
    3. 运行(running)：可运行状态(runnable)的线程获得了cpu时间片（ timeslice ），执行程序代码。
    4. 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cputimeslice，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种：
    (一). 等待阻塞：运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列( waitting queue )中。
    (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。
    (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。
    5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。
    ------------------------------------------------------------------------
    操作系统线程的5种状态：
    
    新建状态：
    线程创建但没有启动
    就绪状态：
    线程处于可运行的状态，当线程获得CPU的时间片后会被执行，时间片耗尽或主动放弃当次时间片（yield方法）时再次进入就绪状态。
    运行状态：
    线程得到时间片被CPU执行
    阻塞状态：
    线程放弃CPU的时间片（一直到某个条件达成），主动进入阻塞的状态。
    同步阻塞：线程由于尝试获得对象的同步锁但无法取得时，进入锁池，等待其他线程释放该对象的锁。
    等待阻塞：线程主动放弃对对象上的锁的占用，进入等待对象通知的队列。指wait方法
    其他阻塞：线程主动进入休眠状态，等待条件达成。指sleep、join方法或I/O请求。
    终止状态：
    线程任务结束或异常退出
    ```

    ![img](https://i.loli.net/2021/05/19/orw1uSstNE9RBJZ.png)

13. 同步方法和同步代码块的区别是什么？

    ```java
    java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）,将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。
    1. 同步方法 
        即有synchronized关键字修饰的方法。 
        由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
        代码如：public synchronized void save(){}
    注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类
    2. 同步代码块 
        即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步.
        代码如：  synchronized(object){  }
    注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 
    
    同步代码块可以选择以什么来加锁，比同步方法要更颗粒化，我们可以选择只同步会发生问题的部分代码而不是整个方法。
    ```

    ![image-20210519222533706](https://i.loli.net/2021/05/19/QuLbIO7CdJir9MH.png)

14. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

    ```java
    
    ```

    