1. 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

   ```java
   Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
   Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。
   ```

2. JDK和JRE的区别是什么？

   ```java
   JRE： Java Runtime Environment 
   JDK：Java Development Kit
   JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。
   JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。
   如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。
   JRE根据不同操作系统（如：windows，linux等）和不同JRE提供商（IBM,ORACLE等）有很多版本 
   再说说java的跨平台吧:
     java源程序先经过javac编译器编译成二进制的.class字节码文件（java的跨平台指的就是.class字节码文件的跨平台，.class字节码文件是与平台无关的），.class文件再运行在jvm上，java解释器（jvm的一部分）会将其解释成对应平台的机器码执行，所以java所谓的跨平台就是在不同平台上安装了不同的jvm，而在不同平台上生成的.class文件都是一样的，而.class文件再由对应平台的jvm解释成对应平台的机器码执行
   
   最后解释下机器码和字节码的区别:
    一，机器码，完全依附硬件而存在～并且不同硬件由于内嵌指令集不同，即使相同的0 1代码
   意思也可能是不同的～换句话说，根本不存在跨平台性～比如～不同型号的CPU,你给他个指令10001101，他们可能会解析为不同的结果～
   二，我们知道JAVA是跨平台的，为什么呢？因为他有一个jvm,不论那种硬件，只要你装有jvm,那么他就认识这个JAVA字节码～～～～至于底层的机器码，咱不用管，有jvm搞定，他会把字节码再翻译成所在机器认识的机器码～～～
   ```

3. ”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？

   ```java
   “static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
   Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
   java中也不可以覆盖private的方法，因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖。
   ```

4. 是否可以在static环境中访问非static变量？

   ```java
   static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。
   ```

5. Java支持的数据类型有哪些？什么是自动拆装箱？

   ```java
   Java语言支持的8种基本数据类型是：
   byte
   short
   int
   long
   float
   double
   boolean
   char
   自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。
   
   Java支持的数据类型包括两种：一种是基本数据类型，包含byte，char,short, boolean ,int , long, float,double;另一种是引用类型：如String等，其实是对象的引用，JVM中虚拟栈中存的是对象的地址，创建的对象实质在堆中，通过地址来找到堆中的对象的过程，即为引用类型。自动装箱就是Java编译器在基本数据类型和对应的对象包装类型间的转化，即int转化为Integer,自动拆箱是Integer调用其方法将其转化为int的过程
   ```

6. Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？

   ```java
   Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。
   -------------------------------------------------------------------------
   方法重写的原则：
   
   重写方法的方法名称、参数列表必须与原方法的相同，返回类型可以相同也可以是原类型的子类型(从Java SE5开始支持)。
   重写方法不能比原方法访问性差（即访问权限不允许缩小）。
   重写方法不能比原方法抛出更多的异常。
   被重写的方法不能是final类型，因为final修饰的方法是无法重写的。
   被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写。
   被重写的方法不能为static。如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足重写条件，那么会发生编译错误；反之亦然。即使父类和子类中的方法都是静态的，并且满足重写条件，但是仍然不会发生重写，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。
   重写是发生在运行时的，因为编译期编译器不知道并且没办法确定该去调用哪个方法，JVM会在代码运行的时候作出决定。
       
   方法重载的原则：
   
   方法名称必须相同。
   参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。
   方法的返回类型可以相同也可以不相同。
   仅仅返回类型不同不足以成为方法的重载。
   重载是发生在编译时的，因为编译器可以根据参数的类型来选择使用哪个方法。
   重写和重载的不同：
   
   方法重写要求参数列表必须一致，而方法重载要求参数列表必须不一致。
   方法重写要求返回类型必须一致(或为其子类型)，方法重载对此没有要求。
   方法重写只能用于子类重写父类的方法，方法重载用于同一个类中的所有方法。
   方法重写对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有任何限制。
   父类的一个方法只能被子类重写一次，而一个方法可以在所有的类中可以被重载多次。
   重载是编译时多态，重写是运行时多态。
   ```

7. Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？

   ```JAVA
   当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。
   Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。
   Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。
   --------------------------------------------------------------------
   Java中的构造函数是为了初始化对象的，构造函数的函数名和类名一致，默认的构造函数没有参数，没有返回值，构造函数的函数体内，没有内容。 构造函数的重载是函数名与类名相同，参数类型不同，参数不同。同样的作用也是为了初始化对象的。 Java中没有拷贝构造函数的概念！
   ---------------------------------------------------------------------
   关于复制构造函数：C++中的复制构造函数通常有三种作用
   1.对象作为函数参数
   2.对象作为函数返回值
   3.使用一个对象对另一个对象初始化。
   C++语法允许用户定义自己的复制构造函数以实现自定义的复制，比如说进行深复制。Java并不支持这样的复制构造函数。但是这并不代表Java中没有这种机制，在Java中Object类的clone()方法就是这种机制的体现。而且通过以上三种方式对Java对象进行的操作都是对引用的操作，不像C++里面是对原对象的操作，因此Java中也不需要考虑需要使用复制构造函数这种问题。
   ```

8. Java支持多继承么？

   ```JAVA
   Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。
   ```

9. 接口和抽象类的区别是什么？

   ```JAVA
   	接口和抽象类的区别: 1、定义接口的关键字是interface ，抽象类的关键字是abstract class 2、接口中的方法都是抽象的，抽象类中可以有方法的实现（即非抽象方法） 3、一个类可以实现多个接口，但只能继承一个抽象类，所以一般来说，可以使用接口实现的尽量使用接口实现。比如Runnable就比Thread使用频率高的多 4、接口和抽象类中都可以定义变量，但是接口中定义的必须是公共的、静态的、Final的，抽象类中的变量跟普通类中的没有区别。 5、抽象类可以包含静态方法，但是接口中不可以！ 6、接口中的方法必须是public的，抽象类中的方法可以使public 和 protected的 7、从设计上来说，接口是对一系列行为的抽象，而抽象类是对事物的抽象。 
       两者相同点: 1.抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 2.抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类还只能是抽象类。同样，一个类实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 
       两者不同点 : 什么时候使用抽象类和接口？ 1.如果有一些需要默认实现的方法并且要求子类重写，那么使用抽象类。 2.如果想实现多重继承，那么必须使用接口 3.如果基本功能在不断改变，那么就需要使用抽象类
   -------------------------------------------------------------------------
   1.接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法
   2.接口中的实例变量默认是final类型的，而抽象类中则不一定
   3.一个类可以实现多个接口，但最多只能实现一个抽象类
   4.一个类实现接口的话要实现接口的所有方法，而抽象类不一定
   5.接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象
   ```

10. 进程和线程的区别是什么？

    ```JAVA
    进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
    线程与进程的区别归纳：
    
    a.地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
    b.通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
    c.调度和切换：线程上下文切换比进程上下文切换要快得多。
    d.在多线程OS中，进程不是一个可执行的实体。
    ------------------------------------------------------------------------
    进程是运行中的程序，线程是进程的内部的一个执行序列
    进程是资源分配的单元，线程是执行行单元
    进程间切换代价大，线程间切换代价小
    进程拥有资源多，线程拥有资源少
    多个线程共享进程的资源
    ```

11. 创建线程有几种不同的方式？你喜欢哪一种？为什么？

    ```JAVA
    ①继承Thread类（真正意义上的线程类），是Runnable接口的实现。
    ②实现Runnable接口，并重写里面的run方法。
    ③使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现。
    
    调用线程的start()：启动此线程；调用相应的run()方法
    
    继承于Thread类的线程类，可以直接调用start方法启动线程（使用static也可以实现资源共享）.一个线程（对象）只能够执行一次start()，而且不能通过Thread实现类对象的run()去启动一个线程。
    
    实现Runnable接口的类需要再次用Thread类包装后才能调用start方法。（三个Thread对象包装一个类对象，就实现了资源共享）。
    线程的使用的话，注意锁和同步的使用。（多线程访问共享资源容易出现线程安全问题）
    
    一般情况下，常见的是第二种。
    
    * Runnable接口有如下好处：
    
    *①避免点继承的局限，一个类可以继承多个接口。
    
    *②适合于资源的共享
    
    /*
     * Thread的常用方法：
     * 1.start()：启动线程并执行相应的run()方法
     * 2.run():子线程要执行的代码放入run()方法中
     * 3.currentThread()：静态的，调取当前的线程
     * 4.getName():获取此线程的名字
     * 5.setName():设置此线程的名字
     * 6.yield():调用此方法的线程释放当前CPU的执行权（很可能自己再次抢到资源）
     * 7.join():在A线程中调用B线程的join()方法，表示：当执行到此方法，A线程停止执行，直至B线程执行完毕，
     * A线程再接着join()之后的代码执行
     * 8.isAlive():判断当前线程是否还存活
     * 9.sleep(long l):显式的让当前线程睡眠l毫秒  (只能捕获异常，因为父类run方法没有抛异常)
     * 10.线程通信（方法在Object类中）：wait()   notify()  notifyAll()
     *
     *设置线程的优先级（非绝对，只是相对几率大些）
     * getPriority()：返回线程优先值
     * setPriority(int newPriority)：改变线程的优先级
     */
    ```

12. 概括的解释下线程的几种可用状态。

    ```JAVA
    1. 新建(new)：新创建了一个线程对象。
    2. 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的 start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。
    3. 运行(running)：可运行状态(runnable)的线程获得了cpu时间片（ timeslice ），执行程序代码。
    4. 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cputimeslice，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种：
    (一). 等待阻塞：运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列( waitting queue )中。
    (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。
    (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。
    5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。
    ------------------------------------------------------------------------
    操作系统线程的5种状态：
    
    新建状态：
    线程创建但没有启动
    就绪状态：
    线程处于可运行的状态，当线程获得CPU的时间片后会被执行，时间片耗尽或主动放弃当次时间片（yield方法）时再次进入就绪状态。
    运行状态：
    线程得到时间片被CPU执行
    阻塞状态：
    线程放弃CPU的时间片（一直到某个条件达成），主动进入阻塞的状态。
    同步阻塞：线程由于尝试获得对象的同步锁但无法取得时，进入锁池，等待其他线程释放该对象的锁。
    等待阻塞：线程主动放弃对对象上的锁的占用，进入等待对象通知的队列。指wait方法
    其他阻塞：线程主动进入休眠状态，等待条件达成。指sleep、join方法或I/O请求。
    终止状态：
    线程任务结束或异常退出
    ```

    ![img](https://i.loli.net/2021/05/19/orw1uSstNE9RBJZ.png)

13. 同步方法和同步代码块的区别是什么？

    ```java
    java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）,将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。
    1. 同步方法 
        即有synchronized关键字修饰的方法。 
        由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。
        代码如：public synchronized void save(){}
    注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类
    2. 同步代码块 
        即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步.
        代码如：  synchronized(object){  }
    注：同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 
    
    同步代码块可以选择以什么来加锁，比同步方法要更颗粒化，我们可以选择只同步会发生问题的部分代码而不是整个方法。
    ```

    ![image-20210519222533706](https://i.loli.net/2021/05/19/QuLbIO7CdJir9MH.png)

14. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

    ```java
    监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。
    

在 java 虚拟机中, 每个对象( Object 和 class )通过某种逻辑关联监视器,每个监视器和一个对象引用相关联, 为了实现监视器的互斥功能, 每个对象都关联着一把锁.
     
    一旦方法或者代码块被 synchronized 修饰, 那么这个部分就放入了监视器的监视区域, 确保一次只能有一个线程执行该部分的代码, 线程在获取锁之前不允许执行该部分的代码
    ```


16. 什么是死锁(deadlock)？

    ```java
    所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：
    (1)互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
    (2)不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
    (3)请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
    (4)循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。
    ```

17. 如何确保N个线程可以访问N个资源同时又不导致死锁？

    ```java
    使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。
    ```

18. Java集合类框架的基本接口有哪些？

    ```java
    集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。
    Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：
    Collection：代表一组对象，每一个对象都是它的子元素。
    Set：不包含重复元素的Collection。
    List：有顺序的collection，并且可以包含重复元素。
    Map：可以把键(key)映射到值(value)的对象，键不能重复。
    ---------------------------------
    总共有两大接口：Collection 和Map ，一个元素集合，一个是键值对集合； 其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合； 而ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口，这几个都比较常用； HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好；
    java.util.Collection [I]
    |—java.util.List [I]
        |—java.util.ArrayList [C]
        |—java.util.LinkedList [C]
        |—java.util.Vector [C]
            |—java.util.Stack [C]
    |—java.util.Set [I]
        |—java.util.HashSet [C]
        |—java.util.SortedSet [I]
            |—java.util.TreeSet [C]
    ------------------------------------------------
    java.util.Map [I]
    |—java.util.SortedMap [I]
        |—java.util.TreeMap [C]
    |—java.util.Hashtable [C]
    |—java.util.HashMap [C]
        |—java.util.LinkedHashMap [C]
    |—java.util.WeakHashMap [C]
    ```

19. 为什么集合类没有实现Cloneable和Serializable接口？

    ```java
    克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。
    
    实现Serializable序列化的作用
    将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；
    按值将对象从一个从一个应用程序域发向另一个应用程序域。
    实现 Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。
    
    Cloneable 标识一个类可以被克隆，Serializable 标识一个类可以被序列化
    集合的接口没有实现这两个接口
    但是集合具体的类是有实现这两个接口的
    接口不是具体的容器，所以不需要实现这两个接口，也没有意义
    ```

20. 什么是迭代器(Iterator)？

    ```java
    迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。
    　　Java中的Iterator功能比较简单，并且只能单向移动：
    　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
    　　(2) 使用next()获得序列中的下一个元素。
    　　(3) 使用hasNext()检查序列中是否还有元素。
    　　(4) 使用remove()将迭代器新返回的元素删除。
    　　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。
    ```

21. Iterator和ListIterator的区别是什么？

    ```java
    Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
    Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
    ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。
    ```

    ![img](https://i.loli.net/2021/05/20/81m6YvtkpLIZGCV.png)

    ![img](https://i.loli.net/2021/05/20/36VpvxT5oXznq2A.png)

22. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？

    ```java
    一：快速失败（fail—fast）
        在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。
    
        原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
        注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。
        场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。
    
    二：安全失败（fail—safe）
          采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
          原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。
          缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
          场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。
    ```

23. Java中的HashMap的工作原理是什么？

    ```java
    Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。
    ----------------------------------------------------------------------------------------------------------------
    hashmap是一个key-value键值对的数据结构，从结构上来讲在jdk1.8之前是用数组加链表的方式实现，jdk1.8加了红黑树，hashmap数组的默认初始长度是16，hashmap数组只允许一个key为null，允许多个value为null
    hashmap的内部实现，hashmap是使用数组+链表+红黑树的形式实现的，其中数组是一个一个Node[]数组，我们叫他hash桶数组，它上面存放的是key-value键值对的节点。HashMap是用hash表来存储的，在hashmap里为解决hash冲突，使用链地址法，简单来说就是数组加链表的形式来解决，当数据被hash后，得到数组下标，把数据放在对应下表的链表中。
    然后再说一下hashmap的方法实现
    put方法，put方法的第一步，就是计算出要put元素在hash桶数组中的索引位置，得到索引位置需要三步，去put元素key的hashcode值，高位运算，取模运算，高位运算就是用第一步得到的值h，用h的高16位和低16位进行异或操作，第三步为了使hash桶数组元素分布更均匀，采用取模运算，取模运算就是用第二步得到的值和hash桶数组长度-1的值取与。这样得到的结果和传统取模运算结果一致，而且效率比取模运算高
    jdk1.8中put方法的具体步骤，先判断hashmap是否为空，为空的话扩容，不为空计算出key的hash值i，然后看table[i]是否为空，为空就直接插入，不为空判断当前位置的key和table[i]是否相同，相同就覆盖，不相同就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入键值对，如果不是开始遍历链表插入，如果遇到重复值就覆盖，否则直接插入，如果链表长度大于8，转为红黑树结构，执行完成后看size是否大于阈值threshold，大于就扩容，否则直接结束
    get方法就是计算出要获取元素的hash值，去对应位置取即可。
    扩容机制，hashmap的扩容中主要进行两部，第一步把数组长度变为原来的两倍，第二部把旧数组的元素重新计算hash插入到新数组中，在jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。扩容过程第二部一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。
    3.hashmap大小为什么是2的幂次方
    在计算插入元素在hash桶数组的索引时第三步，为了使元素分布的更加均匀，用取模操作，但是传统取模操作效率低，然后优化成h&(length-1)，设置成2幂次方，是因为2的幂次方-1后的值每一位上都是1，然后与第二步计算出的h值与的时候，最终的结果只和key的hashcode值本身有关，这样不会造成空间浪费并且分布均匀，如果不是2的幂次方
    如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。
    ```

24. hashCode()和equals()方法的重要性体现在什么地方？

    ```java
    hashcode和equals组合在一起确定元素的唯一性。
    查找元素时，如果单单使用equals来确定一个元素，需要对集合内的元素逐个调用equals方法，效率太低。因此加入了hashcode方法，将元素映射到随机的内存地址上，通过hashcode快速定位到元素（大致）所在的内存地址，再通过使用equals方法确定元素的精确位置。
    比较两个元素时，先比较hashcode，如果hashcode不同，则元素一定不相等；如果相同，再用equals判断。
    HashMap采用这两个方法实现散列存储，提高键的索引性能。HashSet是基于HashMap实现的。
    ```

25. HashMap和Hashtable有什么区别？

    ```java
    1、HashMap是非线程安全的，HashTable是线程安全的。
    2、HashMap的键和值都允许有null值存在，而HashTable则不行。
    3、因为线程安全的问题，HashMap效率比HashTable的要高。
    4、Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
       一般现在不建议用HashTable, ①是HashTable是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的oncurrentHashMap替代，没有必要因为是多线程而用HashTable。
    ```

26. 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？

    ```java
    ArrayList可以算是Array的加强版，（对array有所取舍的加强）。
    
    存储内容比较：
    Array数组可以包含基本类型和对象类型，
    ArrayList却只能包含对象类型。
    但是需要注意的是：Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。
    
    空间大小比较：
    它的空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小。
    ArrayList的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。（比较麻烦的地方）。
    
    方法上的比较：
    ArrayList作为Array的增强版，当然是在方法上比Array更多样化，比如添加全部addAll()、删除全部removeAll()、返回迭代器iterator()等。
    
    适用场景：
    如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。而且还有一个地方是必须知道的，就是如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。
    ```

27. ArrayList和LinkedList有什么区别？

    ```java
    ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
    ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。
    相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
    LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。
    --------------------------------------------------------------------------------------------------------------
    ArrayList的实现用的是数组，LinkedList是基于链表，ArrayList适合查找，LinkedList适合增删
    发表于 2017-08-05 18:48:29
    ```

28. Comparable和Comparator接口是干什么的？列出它们的区别。

    ```java
    确定两个对象之间的大小关系及排列顺序称为比较，能实现这个比较功能的类或方法称之为比较器，在java中只有两种比较器。
    比较器的分类:内部比较器（Comparable接口）和外部比较器（Comparator接口）。  
        内部比较器（简单点说就是把比较器写在类的内部）的概念:类实现了Comparable接口，然后重写了compareTo方法（这个方法可以看作比较器），这个类就拥有了内部比较器。注意，你一旦实现了比较器，就说明这个类支持排序，比如单例模式的类就不能进行排序。
          下面看看Comparable接口的源码（了解下就行）
                package java.lang;
                public interface Comparable<T>
                {
                    public int compareTo(T o); 
                        1）如果此对象（调用比较器方法的对象）大于指定对象（目标比较对象），返回正整数   
                        2）如果此对象小于指定对象，返回负整数   
                        3）如果此对象等于指定对象，返回零 
                }
    	外部比较器（简单点说就是把比较器写在类的外边，没错！就是在外边新定义了个比较器类！）的概念.新定义一个类，类名随意，但这个类必须实现Comparator接口，重写compare方法，我们把这个称作外部比较器。
            下面看看Comparable接口的源码（了解下就行）
                package java.util;
                public interface Comparator<T> {  
                int compare(T o1, T o2);  
                  1）如果o1大于o2，则返回正整数； 
                  2）如果o1小于o2，则返回负整数 
                  3）如果o1等于o2，则返回零   
                boolean equals(Object obj); //你是不是想问为什么这个方法不需要重写？对不起，我也不是特别清楚，但通常是把这个方法忽略掉，如果
                必须要个说法，你可以说这个方法被默认实现了。
                }
    现在我们有两种比较器的实现方法，用的时候用哪种呢？
    1.我们自定义一个类时，可以选择内部比较器，内部比较器很符合java封装的思想，也就是高内聚，但是！但是！但是！我们平时用到的类往往不是自定义的，而是别人已经写好并且已编译的类，我们只能调用，不能修改其源代码，这时我们就只能用外部比较器了。
    2.还有种情况，我们用到的还是别人已经写好并且已编译的类，他写这个类的时候恰好也实现了内部比较器（我们常用的有基本类型的封装类，String，Date），但是他定义的这种比较方法，不是我们想要的（举个例子，integer的内部比较器是按照数字大小进行比较排序，但是我们的需求是按照数字的绝对值进行排序，这就很尴尬了），这时我们就只能用外部比较器了。
    3.第三种情况，我们平时对对象进行排序，往往需要多种排序方式（举个例子，学生表的排序方式有学号排序，年龄排序，性别排序等等），这时我们也不得不用外部比较器了（也就是定义多个外部比较器类）。
    
    由此看出，外部比较器比内部比较器更灵活，更易维护。
    最最常见的应用还是用在集合（list）和数组的sort()方法中，如果我们想用sort()方法，必须实现存储元素对象的内部比较器或者自定义一个用于存储元素对象之间的外部比较器，不然用sort()方法的时候容器会报错，它不知道用哪种方式进行排序。
    /** 
     * 员工实体 
     * @author Sam 
     * 
     */  
    public class Employee implements Comparable<Employee> {  
          
        private int id;// 员工编号  
        private double salary;// 员工薪资  
          
        public int getId() {  
            return id;  
        }  
      
        public void setId(int id) {  
            this.id = id;  
        }  
      
        public double getSalary() {  
            return salary;  
        }  
      
        public void setSalary(double salary) {  
            this.salary = salary;  
        }  
          
        public Employee(int id, double salary) {  
            super();  
            this.id = id;  
            this.salary = salary;  
        }  
          
        // 为了输出方便，重写toString方法  
        @Override  
        public String toString() {  
            // 简单输出信息  
            return "id:"+ id + ",salary=" + salary;  
        }  
      
        // 比较此对象与指定对象的顺序  
        @Override  
        public int compareTo(Employee o) {  
            // 比较员工编号，如果此对象的编号大于、等于、小于指定对象，则返回1、0、-1  
            int result = this.id > o.id ? 1 : (this.id == o.id ? 0 : -1);  
            // 如果编号相等，则比较薪资  
            if (result == 0) {  
                // 比较员工薪资，如果此对象的薪资大于、等于、小于指定对象，则返回1、0、-1  
                result = this.salary > o.salary ? 1 : (this.salary == o.salary ? 0 : -1);  
            }  
            return result;  
        }  
      
    }  
    
    /** 
     * 测试两种比较器 
     * @author Sam 
     * 
     */  
    public class TestEmployeeCompare {  
      
        /** 
         * @param args 
         */  
        public static void main(String[] args) {  
              
            List<Employee> employees = new ArrayList<Employee>();  
            employees.add(new Employee(2, 5000));  
            employees.add(new Employee(1, 4500));  
            employees.add(new Employee(4, 3500));  
            employees.add(new Employee(5, 3000));  
            employees.add(new Employee(4, 4000));  
            // 内部比较器：要排序的对象要求实现了Comparable接口  
            Collections.sort(employees);  
            System.out.println("通过内部比较器实现：");  
            System.out.println(employees);  
              
            List<Employee> employees2 = new ArrayList<Employee>();  
            employees2.add(new Employee(2, 5000));  
            employees2.add(new Employee(1, 4500));  
            employees2.add(new Employee(4, 3500));  
            employees2.add(new Employee(5, 3000));  
            employees2.add(new Employee(4, 4000));  
            // 外部比较器：自定义类实现Comparator接口  
            Collections.sort(employees2, new EmployeeComparable());  
            System.out.println("通过外部比较器实现：");  
            System.out.println(employees2);  
        }  
      
    }  
      
    /** 
     * 自定义员工比较器 
     * 
     */  
    class EmployeeComparable implements Comparator<Employee> {  
      
        @Override  
        public int compare(Employee o1, Employee o2) {  
            // 比较员工编号，如果此对象的编号大于、等于、小于指定对象，则返回1、0、-1  
            int result = o1.getId() > o2.getId() ? 1 : (o1.getId() == o2.getId() ? 0 : -1);  
            // 如果编号相等，则比较薪资  
            if (result == 0) {  
                // 比较员工薪资，如果此对象的薪资大于、等于、小于指定对象，则返回1、0、-1  
                result = o1.getSalary() > o2.getSalary() ? 1 : (o1.getSalary() == o2.getSalary() ? 0 : -1);  
            }  
            return result;  
        }  
          
    }  
    
    ```

29. 什么是Java优先级队列(Priority Queue)？

    ```java
    PriorityQueue 是从 JDK1.5 开始提供的新的数据结构接口，它是一种基于优先级堆的极大优先级队列。优先级队列是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素。如果不提供 Comparator 的话，优先队列中元素默认按自然顺序排列，也就是数字默认是小的在队列头，字符串则按字典序排列（参阅 Comparable ），也可以根据 Comparator 来指定，这取决于使用哪种构造方法。优先级队列不允许 null 元素。依靠自然排序的优先级队列还不允许插入不可比较的对象（这样做可能导致 ClassCastException ）
    优先级队列有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。
    最后， PriorityQueue 不是线程安全的，入队和出队的时间复杂度是 O(log(n)) 。
    ```

30. 你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？

    ```java
    大O符号表示一个程序运行时所需要的渐进时间复杂度上界。
    其函数表示是：
    对于函数f(n),g(n),如果存在一个常数c，使得f(n)<=c*g(n),则f(n)=O(g(n));
    大O描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。
    大O还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大O符号基于时间，内存，性能选择最好的实现。大O符号可以对大量数据性能给予一个很好的说明。
    O：大O是上界
    Θ：大Θ是平均值
    Ω：大Ω是下界
    O表示算法的时间或者空间复杂度上界。比如数组的插入时间复杂度为O(N),空间复杂度为O(1),链表的插入时间复杂度为O(1),空间复杂度为O(1).
    ```

31. 如何权衡是使用无序的数组还是有序的数组？

    ```java
    有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。
        长度固定用Array
        不确定用ArrayList
        增删频繁用LinkedList
        查询多用ArrayList
    ```

32. Enumeration接口和Iterator接口的区别有哪些？

    ```java
    Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。
    ---------------------------------------------------------------------------------------------
    (01) 函数接口不同
    Enumeration 只有2个函数接口。 通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。
    Iterator 只有3个函数接口。 Iterator除了能读取集合的数据之外，也能数据进行删除操作。
    (02) Iterator 支持 fail-fast 机制，而 Enumeration 不支持
    Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。
    而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
    ```

33. HashSet和TreeSet有什么区别？

    ```java
    HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。
    另一方面，TreeSet是由红黑树来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。
    ```

34. Java中垃圾回收有什么目的？什么时候进行垃圾回收？

    ```java
    垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行。
    垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。
    
    1.回收哪些对象的判定
    垃圾回收最简单的思路是采用引用计数的方式，即记录对象被引用的次数，直到一段时间内对象都没有被其他对象引用，此时可以确定该对象能被回收，引用计数实现简单，运行高效，但是有一个循环引用的问题，即两个本应被回收的对象因为互相引用而无法被回收，针对这个问题又有了弱引用，即把两个互相引用的一个引用计数改为弱引用，弱引用不会使次数加1，c++即是这么做的。
    -------------------------------------------------------------------------------------------------------------
    jvm虚拟机的使用的是根寻路算法，其大致思想是看除堆区以外的内存区域能否通过引用链找到堆中的对象，找不到就证明该对象可以被回收。
    2.如何回收
    jvm有两种回收方式，一种是标记完待回收的对象之后一起释放内存，这种方法的缺点是会产生较多难以重复利用的内存碎片。另一种为了避免内存碎片的出现，将内存分为两块，一块使用，一块不使用，标记完所有待回收的对象之后，将还要使用的内存复制到不使用的区域，然后对使用的整体区域进行内存回收，这种方法没有内存碎片问题，但是每次回收的复制工作很耗性能。
    通过统计发现，在内存中存活越久的对象就越不容易被回收，越是新分配的内存对象就越可能会被回收。根据这个特性，把内存区域分为新生代和老年代(有的虚拟机会分为很多代)，新生代容易被回收，采用复制内存再回收的方法，老年代不容易被回收，采用标记后回收和复制内存相结合的方法。
    3.什么时候回收
    程序员可以手动调用gc[System.gc()]，一般是系统等到新生代的内存区占满了又需要分配内存的时候，这个时候新生代就变成了老年代，等老年代的内存占满之后开始回收老年代所占的内存区。 
    触发主GC（Garbage Collector，垃圾回收）的条件：
    （1）当应用程序空闲时，即没有应用线程在运行时，GC会被调用。
    （2）Java堆内存不足时，GC会被调用。
    ---------------------------------------------------------------------------------------------------------------
    ```

35. System.gc()和Runtime.gc()会做什么事情？

    ```java
    这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。
    ----------------------------------------------------------------------------------------------------------------
    java.lang.System.gc()只是java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。唯一要能说有什么不同那就是在字节码层面上调用前者比调用后者短一点点，前者是1条字节码而后者是2条
    实际运行起来性能几乎一样。不过如果对字节码大小非常非常敏感的话建议用System.gc()。从通常的代码习惯说也是System.gc()用得多些。
    调用 System.gc() 实际上等效于调用： Runtime.getRuntime().gc()
    ```

36. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？

    ```java
    对于Java而言：
    调用时机：当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记，并且判断是否执行finalizer( )方法，如果对象覆盖finalizer( )方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalizer( )方法，但不承诺等待其运行结束。
    finalization的目的：对象逃脱死亡的最后一次机会。（只要重新与引用链上的任何一个对象建立关联即可。）但是不建议使用，运行代价高昂，不确定性大，且无法保证各个对象的调用顺序。可用try-finally或其他替代。
    ------------------------------------------------------------------------------
    链接：https://www.nowcoder.com/questionTerminal/d8eab06913084e42b515633604eef7cd
    来源：牛客网
    
    finalize()方法也叫收尾方法。
    一旦垃圾回收器准备好释放对象占用的存储空间，首先会去调用finalize()方法①进行一些必要的清理工作（对垃圾回收器不能处理的特殊情况进行处理）（例子在下边）②也有可能使该对象重新被引用，我习惯叫这种作用为复活。注意！！每个对象的finalize()方法只能被执行一次，第二次就会直接跳过finalize()方法，这就是为了防止出现对象无限复活，内存空间只增不减。
    一般忽略第二种情况，概念就变成了：一旦垃圾收集器准备好释放对象占用的存储空间（进入第一个回收周期），首先会去调用finalize()方法进行一些必要的清理工作，只有到下一次再进行垃圾回收动作（下一个回收周期）的时候，才会真正释放这个对象所占用的内存空间。
    
    例子：1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。
    
    System.runFinalization()和System.gc()是做什么的呢？ 我个人的理解，这两个函数分别是应用层向JVM发出一个信号，告诉JVM,希望你能尽快的回收内存和调用对象的finaliztion方法，但是只是一个请求，而JVM只保证会尽最大的努力执行，但是具体什么时候执行以及会不会执行都是未知的。
    ```

37. Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?

    ```java
    虚拟机中的共划分为三个代：
        年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent 
    Generation）。其中持久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系
    不大。年轻代和年老代的划分是对垃 圾收集影响比较大的。
    
    年轻代:
       所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生
    命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在
    Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这
    个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了
    的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区
    (Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时
    存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第
    一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，
    Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减
    少被放到年老代的可能。
    
    年老代:
       在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认
    为年老代中存放的都是一些生命周期较长的对象。
    持久代:
       用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应
    用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持
    久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<N>进行设置。
    ```

    ![图片说明](https://i.loli.net/2021/05/20/dOs2YIf5Vxn87A1.png)

38. 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？

    ```java
    串行GC：整个扫描和复制过程均采用单线程的方式，相对于吞吐量GC来说简单；适合于单CPU、客户端级别。
    吞吐量GC：采用多线程的方式来完成垃圾收集；适合于吞吐量要求较高的场合，比较适合中等和大规模的应用程序。
    ---------------------------------------------------------------------------------
    串行收集器：
    特性：
    这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。
    应用场景：
    Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。
    优势：
    简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
        
    吞吐量收集器：
    先讲一下吞吐量的定义：
    吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。
    虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。
    特性：
    吞吐量收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。
    应用场景：
    停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
    ```

39. 在Java中，对象什么时候可以被垃圾回收？

    ```java
    当一个对象到GC Roots不可达时，在下一个垃圾回收周期中尝试回收该对象，如果该对象重写了finalize()方法，并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。但如果这个对象没有重写finalize()方法或者已经执行过这个方法，也自救失败，该对象将会被回收。
    ------------------------------------------------------------------------------
    判断对象是否存活，可以使用引用计数器或者可达性分析两种方法。
    引用计数器：
    当引用计数器为零的时候，表明没用引用再指向该对象，但是引用计数器不能解决循环引用的情况；
    可达性分析：
    1. 当不能从GC Root寻找一条路径到达该对象时， 将进行第一次标记。
    2. 第一次标记后检查对象是否重写了finalize() 和是否已经被调用了finalize()方法。若没有重写finalize()方法或已经被调用，则进行回收。
    3. 在已经重写finalize()方法且未调用的情况下，将对象加入一个F-Queue 的队列中，稍后进行第二次检查。
    4.在第二次标记之前，对象如果执行finalize()方法并完成自救，对象则不会被回收。否则完成第二次标记，进行回收。值得注意的是finalize()方法并不可靠。
    ```

40. JVM的永久代中会发生垃圾回收么？

    ```java
    永生代也是可以回收的，条件是 1.该类的实例都被回收。 2.加载该类的classLoader已经被回收 3.该类不能通过反射访问到其方法，而且该类的java.lang.class没有被引用 当满足这3个条件时，是可以回收，但回不回收还得看jvm。
    ```

43. Java中的两种异常类型是什么？他们有什么区别？

    ```java
    Throwable包含了错误(Error)和异常(Excetion两类)
    Exception又包含了运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)
    (1) Error是程序无法处理了, 如果OutOfMemoryError等等, 这些异常发生时, java虚拟机一般会终止线程 .
    (2) 运行时异常都是RuntimeException类及其子类,如 NullPointerException、IndexOutOfBoundsException等, 这些异常是不检查的异常, 是在程序运行的时候可能会发生的, 所以程序可以捕捉, 也可以不捕捉. 这些错误一般是由程序的逻辑错误引起的, 程序应该从逻辑角度去尽量避免.
    (3) 检查异常是运行时异常以外的异常, 也是Exception及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的, 否则不能通过编译. 如IOException、SQLException等
    ```

44. Java中Exception和Error有什么区别？

    ```java
    Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。
    ---------------------------------------------------------------------------------
    Error类和Exception类的父类都是throwable类，他们的区别是：
    Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
    Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。
    Exception类又分为运行时异常（Runtime Exception）和受检查的异常(Checked Exception )，运行时异常;ArithmaticException,IllegalArgumentException，编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。而受检查的异常，要么用try。。。catch捕获，要么用throws字句声明抛出，交给它的父类处理，否则编译不会通过。
    
    常见的异常;
    ArrayIndexOutOfBoundsException 数组下标越界异常，
    ArithmaticException 算数异常 如除数为零
    NullPointerException 空指针异常
    IllegalArgumentException 不合法参数异常
    ```

45. throw和throws有什么区别？

    ```java
    1、Throw用于方法内部，Throws用于方法声明上
    2、Throw后跟异常对象，Throws后跟异常类型
    3、Throw后只能跟一个异常对象，Throws后可以一次声明多种异常类型
    ----------------------------------------------------------------------------------
    1. Throw用于抛出异常对象，后面跟的时异常对象。是语句抛出一个异常。多用在函数内。
    语法：throw(异常对象)
               throw e;
    2.Throws是方法可能抛出异常的声明（用在声明方法时，表示该方法可能要抛出异常）
    语法：修饰符 返回值类型 方法名  参数类型  throws异常类
            public void test throws Exception1,Exception2(){}
    ```

46. 异常处理完成以后，Exception对象会发生什么变化？

    ```java
    Exception对象会在下一个垃圾回收过程中被回收掉。
    -------------------------------------------------------------------------------
    异常处理对象在异常处理完后,没有引用指向它,变成了不可达对象.
        它将在接下来JVM进行gc操作时被标记为"不可达", 如果该Exception实例实现了finalize方法,那么就会安排到F-queue队列中等待执行finalize方法(但是由于F-queue所在线程的优先级很低,所以可能一直得不到执行,而长时间留在该队列中);
        再下一次执行gc时,如果Exception对象已经执行完成finalize方法,它将被回收(彻底抹去内存中的数据).
    ```

47. finally代码块和finalize()方法有什么区别？

    ```java
    无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。
    ---------------------------------------------------------------------------------
    1. final是关键字，final可以修饰类、方法、属性。
        如果一个类被final修饰，那么这个类就是最终类，不能派生出新的子类，不能作为父类被继承，该类中的所有方法都不能被重写，但是final类中的成员变量是可以改变的，要想final类中的成员变量的不可以改变，必须给成员变量添加final修饰。因此，一个类不能同时被final和abstract修饰，这两个关键字相互矛盾。
        如果final修饰方法，那么这个方法是最终方法，不允许任何子类重写该方法，但子类仍可以使用该方法，注意：final参数用来表示这个参数在这个函数内部不允许被修改。
        final修饰属性，被final修饰的变量不可变。这里的不可变有两重含义：引用不可变和对象不可变。final指的是引用不可变，即它只能指向初始化时指向的那个对象，而不关心指向对象内容的变化。因此，被final修饰的变量必须初始化，该变量其实就是常量。
    2. finally作为异常处理的一部分，只能用在try/catch语句快中，finally代码块中的语句一定会被执行，经常被用来释放资源，如IO流和数据库资源的释放。
    3. finalize是Object类的一个方法，该方法在Object类中声明：
            protected void finalize() throws Throwable { } 
        在垃圾回收器执行时会调用被回收对象的finalize()方法，可以覆盖此方法来实现对其资源的回收。注意：一旦垃圾回收器准备释放某个对象占用的空间，将首先调该对象的
    finalize()方法，并且在下一次垃圾回收动作发生时，才真正将该对象占用的内存回收。
    ```

48. 什么是Applet？

    ```java
    java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。
    ------------------------------------------------------------------------------
    Java应用小程序，可以直接嵌入到网页中，并能够产生特殊的效果，applet经编译后会产生.class文件，把.class文件嵌入到html页面中，用户在链接网页时，applet便会伴随网页一起下载到用户计算机运行。
    applet主要用来创建动态交互的web应用程序。
    -------------------------------------------------------------------------------
    Applet是一种Java语言的网页应用程序把，Java语言的程序分为三种：Applet（网页应用小程序（no main））、Application（完整应用程序）、Servlet（服务器中应用程序）
    ```

49. 解释一下Applet的生命周期.

    ```java
    applet可以经历下面的状态：
    Init：每次被载入的时候都会被初始化。
    Start：开始执行applet。
    Stop：结束执行applet。
    Destroy：卸载applet之前，做最后的清理工作。
    -----------------------------------------------------------------------------
    Applet 类中的四个方法给了你构建 applet 程序时的框架：
    
    1.init： 这个方法适用于你的 applet 程序所需要的任何初始化。它在 applet 标记中的参数标签被处理后被调用。
    2.start： 这个方法在浏览器调用 init 方法后被自动调用。它也在无论何时使用者在去其他页面后返回到包含 applet 的页面时被调用。
    3.stop： 这个方法在使用者离开有 applet 所在的页面时被自动调用。因此，它在同一个 applet 中能被重复调用。
    4.destroy： 这个方法仅当浏览器正常关闭时被自动调用。因为 applet 程序是生存在 HTML 页面上的，你不应该在使用者离开有 applet 的网页后留下资源。
    5.paint： 在 start() 方法之后被立即调用，或是在 applet 需要在浏览器上重现它自身的任何时候。paint() 方法实际上是继承自 java.awt。
    ```

50. 当applet被载入的时候会发生什么？

    ```java
    首先，创建applet控制类的实例，然后初始化applet，最后开始运行。
    ```

51. Applet和普通的Java应用程序有什么区别？

    ```java
    applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机。
    进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行。
    最后，Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。
    --------------------------------------------------------------------------------
    （1）运行方式不同。Java Applet程序不能单独运行，它必须依附于一个用HTML语言编写的网页并嵌入其中，通过与Java兼容的浏览器来控制执行。Java Application是完整的程序，可以独立运行，只要有支持Java的虚拟机，它就可以独立运行而不需要其他文件的支持。
        
    （2）运行工具不同。运行Java Applet程序的解释器不是独立的软件，而是嵌在浏览器中作为浏览器软件的一部分。Java Application程序被编译以后，用普通的Java解释器就可以使其边解释边执行，而Java Applet必须通过网络浏览器或者Applet观察器才能执行。
        
    （3）程序结构不同。每个Java Application程序必定含有一个并且只有一个main方法，程序执行时，首先寻找main方法，并以此为入口点开始运行。含有main方法的那个类，常被称为主类，也就是说，Java Application程序都含有一个主类。而Applet程序则没有含main方法的主类，这也正是Applet程序不能独立运行的原因。尽管Applet没有含main方法的主类，但Applet一定有一个从 java.applet.Applet派生的类，它是由Java系统提供的。
        
    （4）Java Applet程序可以直接利用浏览器或AppletViewer提供的图形用户界面，而Java Application程序则必须另外书写专用代码来营建自己的图形界面。
        
    （5）受到的限制不同Java Application程序可以设计成能进行各种操作的程序，包括读/写文件的操作，但是 Java Applet 对站点的磁盘文件既不能进行读操作，也不能进行写 操作。然而，由于 Applet的引入，使Web页面具有动态多媒体效果和可交互性能，这使由名为超文本、实为纯文本的HTML语言编写成的Web页面真正具有了超文本功能，不但可以显示文本信息，而且还可以有各种图片效果和动态图形效果，从而使页面显得生动美丽；另外，Applet使Web页面增加了按钮等功能，从而增加了交互性。
    ```

52. Java applet有哪些限制条件？

    ```java
    主要是由于安全的原因，给applet施加了以下的限制：
    applet不能够载入类库或者定义本地方法。
    applet不能在宿主机上读写文件。
    applet不能读取特定的系统属性。
    applet不能发起网络连接，除非是跟宿主机。
    applet不能够开启宿主机上其他任何的程序。
    ```

53. 什么是不受信任的applet？

    ```java
    不受信任的applet是不能访问或是执行本地系统文件的Java applet，默认情况下，所有下载的applet都是不受信任的。
    ```

54. 从网络上加载的applet和从本地文件系统加载的applet有什么区别？

    ```java
    当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制。
    当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的。
    从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。
    ---------------------------------------------------------------------------------
    默认情况下，所有applet都是不受信任的。本地applet的话相当于受信任，不像网络上加载的applet，处于安全的原因会受到各种限制条件，像不能载入类库和调用本地方法，不能读写本地文件系统，不能发起除本机之外的网络连接等；本地加载的applet则允许对文件的读写，加载类库，执行其他程序等操作。
    ```

55. applet类加载器是什么？它会做哪些工作？

    ```java
    当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。
    当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的。
    ```

56. applet安全管理器是什么？它会做哪些工作？

    ```java
    applet安全管理器是给applet施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。安全管理器的作用在于，用户在执行某个操作时，调用安全管理器来进行check，有此权限则通过，没有则抛异常。
    一旦某个类被加载到虚拟机中，并由检验器检查过之后，Java平台的第二种安全机制就会启动，这个机制就是安全管理器。安全管理器是一个负责控制某个操作是否允许执行的类。安全管理器负责检查的操作包括以下几个：
    1.创建一个新的类加载器；
    2.退出虚拟机；
    3.使用反射访问另一个类的成员；(不通过反射进行访问时，编译期间已经对访问控制权限进行了检查，因此若正确编译了，就不会在运行时出问题)
    4.访问本地文件；
    5.打开socket连接；
    6.启动打印作业；
    7.访问系统剪贴板；
    8.访问AWT事件队列；
    9.打开一个顶层窗口。
    ```

57. 弹出式选择菜单(Choice)和列表(List)有什么区别?

    ```java
    Choice是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice中一次只能选中一个选项。List同时可以有多个元素可见，支持选中一个或者多个元素。
    ```

58. 什么是布局管理器？

    ```java
    布局管理器用来在容器中组织组件。
    --------------------------------------------------------------------------
    java未来实现跨平台的的特效并获得动态的布局效果，将容器内所以组件的大小，位置，顺序，间隔交给布局管理器，一共有5种布局管理： FlowLayout（流式布局管理器）,BorderLayout（边界布局管理器）,GridLayout（网格布局管理器）,CardLayout（卡片布局管理器）和GridBagLayout（矩形单元网格布局管理器）
    -----------------------------------------------------------------------------
    组件在容器比如(JFrame)中的位置和大小是由布局管理器来决定的。所有的容器都会使用一个布局管理器，通过它来自动进行组件的布局管理。
    ```

59. 滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？

    ```java
    Scrollbar是一个组件，不是容器。而ScrollPane是容器。ScrollPane自己处理滚动事件。
    ---------------------------------------------------------------------------
    在设置界面时，可能会遇到在一个较小的容器窗体中显示一个较大部分的内容，这时可以使用JScrollPane面板，JscrollPane面板是带滚动条的面板，也是一种容器，但是常用于布置单个控件，并且不可以使用布局管理器。如果需要在JScrollPane面板中放置多个控件，需要将多个控件放置到JPanel 面板上，然后将JPanel面板作为一个整体控件添加到JScrollPane控件上。
    ```

60. 哪些Swing的方法是线程安全的？

    ```java
    只有3个线程安全的方法： repaint(), revalidate(), and invalidate()。
    ---------------------------------------------------------------------------
    Swing的规则是：一旦Swing组件被具现化（realized），所有可能影响或依赖于组件状态的代码都应该在事件派发线程中执行。所以有这3个线程安全的方法：repaint()，revalidate()，andinvalidate()。
    ```

61. 说出三种支持重绘(painting)的组件。

    ```java
    Canvas, Frame, Panel,和Applet支持重绘。
    ```

62. 什么是裁剪(clipping)？

    ```java
    限制在一个给定的区域或者形状的绘图操作叫做裁剪。
    --------------------------------------------------------------------------------
    ```

63. MenuItem和CheckboxMenuItem的区别是什么？

    ```java
    <menuitem> 标签定义用户可以从弹出菜单调用的命令/菜单项目。<menuitem> 标签是 HTML5 中的新标签。
    CheckboxMenuItem类继承自MenuItem类，此类表示一个可包括在菜单中的复选框。选择菜单中的复选框可以将其状态从 "开" 更改为 "关" 或者从 "关" 更改为 "开"
    --------------------------------------------------------------------------------
    menu 菜单，item 菜单选项是一个父类。 checbox，检查盒，继承了父类，有新的方法
    ```

64. 边缘布局(BorderLayout)里面的元素是如何布局的？

    ```java
    BorderLayout里面的元素是按照容器的东西南北中进行布局的。
    -----------------------------------------------------------------------
    边界式布局时按照东西南北中五个方位进行布局的，默认就是边界式布局，且会填充满
    ```

65. 网格包布局(GridBagLayout)里面的元素是如何布局的？

    ```java
    GridBagLayout里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于1行或一列。因此，行数和列数可以有不同的大小。
    ```

66. Window和Frame有什么区别？

    ```java
    Frame类继承了Window类，它定义了一个可以有菜单栏的主应用窗口。
    ------------------------------------------------------------------------------
    Frame是一个窗体，包括标题栏，边框等。主要用于一个应用程序的主题框架结构。
    Window是一个窗口，什么都没有，包括边框。
    ```

67. 裁剪(clipping)和重绘(repainting)有什么联系？

    ```java
    当窗口被AWT重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。
    ```

68. 事件监听器接口(event-listener interface)和事件适配器(event-adapter)有什么关系？

    ```java
    事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。
    ---------------------------------------------------------------------------------
    事件***接口的方法是很多的，可能有5个，10个，如果直接实现这个接口就要重写所有的方法，适配器是一种设计模式，就是我写一个抽象方法，实现接口所有方法，但是都没有语句，你要实现哪个方法，就重写哪个方法，不用一股脑都重写.
    ```

69. GUI组件如何来处理它自己的事件？

    ```java
    GUI组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。
    ---------------------------------------------------------------------------------
    GUI的意思 就是图形用户界面 ，是java 界面布局方面的知识
    ```

70. Java的布局管理器比传统的窗口系统有哪些优势？

    ```java
    Java使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。
    ------------------------------------------------------------------------------
    大概是说布局管理器的组件会随着不同平台，去更改组件和整体的比例，整体位置跟原本的一样大小可能会变化。
    ```

71. Java的Swing组件使用了哪种设计模式？

    ```java
    Java中的Swing组件使用了MVC（模型-视图-控制器)设计模式。
    ```

72. 什么是JDBC？

    ```java
    JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。
    ---------------------------------------------------------------------------------
    JDBC（Java DataBase Connectivity）,是一套面向对象的应用程序接口（API），制定了统一的访问各类关系数据库的标准接口，为各个数据库厂商提供了标准的实现。通过JDBC技术，开发人员可以用纯Java语言和标准的SQL语句编写完整的数据库应用程序，并且真正地实现了软件的跨平台性。
    通常情况下使用JDBC完成以下操作：
    1.同数据库建立连接；
    2.向数据库发送SQL语句；
    3.处理从数据库返回的结果；
    JDBC具有下列优点：
    1.JDBC与ODBC(Open Database Connectivity，即开放数据库互连）十分相似，便于软件开发人员理解；
    2.JDBC使软件开发人员从复杂的驱动程序编写工作中解脱出来，可以完全专注于业务逻辑开发；
    3.JDBC支持多种关系型数据库，大大增加了软件的可移植性；
    4.JDBC API是面向对象的，软件开发人员可以将常用的方法进行二次封装，从而提高代码的重用性；
    ----------------------------------------------------------------------------------
    JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用 Java语言 编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序
    ----------------------------------------------------------------------------------
    说白了，他就是一个数据库的链接标准，有了它就不用为每种数据库写连接程序啦，直接用它可以链接各种数据库
    ```

73. 解释下驱动(Driver)在JDBC中的角色。

    ```java
    JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。
    ----------------------------------------------------------------------------------
       JDBC是一套规范(通俗的说就是一套接口),它本身是没有针对具体数据库操作提供实现的, 所以谁要让自家的数据库适配JDBC,就实现这套接口即可. 
       一般叫实现JDBC规范的jar包为JDBC驱动(我们通过JDBC接口执行数据库操作命令,具体让数据库操作的是驱动程序).
    ```

74. Class.forName()方法有什么作用？

    ```java
    初始化参数指定的类，并且返回此类对应的Class 对象
    ----------------------------------------------------------------------------------
    在初始化一个类，生成一个实例的时候，newInstance()方法和new关键字除了一个是方法，一个是关键字外，它们的区别在于创建对象的方式不一样，前者是使用类加载机制，后者是创建一个新类。 从JVM的角度看，我们使用关键字new创建一个类的时候，这个类可以没有被加载。但是使用newInstance()方法的时候，就必须保证： 1、这个类已经加载； 2、这个类已经连接了。 而完成上面两个步骤的正是Class的静态方法forName()所完成的，这个静态方法调用了启动类加载器，即加载 java API的那个加载器。
    ```

75. PreparedStatement比Statement有什么优势？

    ```java
    PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。
    -------------------------------------------------------------------------------
    1.PreparedStatement是预编译的，性能会比Statement好 2.PreparedStatement可以防止sql注入，安全性比Statement高 3.PreparedStatements可以写动态参数化的查询，提高了代码的可扩展性与可维护性。
    ```

76. 什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？

    ```java
    CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是：allableStatement Connection.prepareCall();
    ---------------------------------------------------------------------------------
    不鼓励使用存储过程，存储过程这种“一次优化，多次使用”的策略节省了每次执行时候编译的时间，但也是该策略导致了一个致命的缺点：可能会使用错误的执行计划。 存储过程难以调试，虽然有些DB提供了调试功能，但是一般的账号根本就没有那种权限，更何况线上的数据库不可能会给你调试权限的，再进一步就算能调试效果也比程序的调试效果要差很多。 可移植性差，当碰到切换数据种类的时候，存储过程基本就会歇菜。如果业务数据模型有变动，存储过程必须跟着业务代码一起更改，如果是大型项目，这种改动是空前的，是要命的。
    ----------------------------------------------------------------------------------
    ```

77. 数据库连接池是什么意思？

    ```java
    像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。
    ----------------------------------------------------------------------------------
    数据库连接的建立、关闭资源消耗巨大。 传统数据库访问方式：一次数据访问对应一个物理连接，每次操作数据库都要打开关闭该物理连接，系统性能严重受损。 解决方案：数据库连接池。系统初始运行时，主动建立足够足够的连接，组成一个池，每次应用程序请求数据库连接时，无需重新打开连接，而是从池中取出已有的连接，使用完后，不再关闭，而是归还。
    ----------------------------------------------------------------------------------
    数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；
    连接池是存储、管理数据库连接的容器，应用程序把获取数据库连接的功能委托给连接池，每个连接池都有一个上限，如果连接池达到上限，应用程序线程申请连接时被堵塞，等待其他线程释放连接，每个线程使用完连接后并不马上关闭，至少把它返还给连接池。由于连接的共享，不会频繁的创建、销毁连接，因此就不会增加创建连接的开销，也不会出现socket释放延迟现象。
    ```

78. 什么是RMI？

    ```java
    Java RMI（Remote Method Invocation）--Java的远程方法调用是Java所特有的分布式计算技术，它允许运行在一个Java虚拟机上的对象调用运行在另一个Java虚拟机上的对象的方法，从而使Java编程人员可以方便地在网络环境中作分布式计算。面向对象设计要求每个任务由最适合该任务的对象执行，RMI将这个概念更深入了一步，使任务可以在最适合该任务的机器上完成。 RMI定义了一组远程接口，可以用于生成远程对象。客户机可以象调用本地对象的方法一样用相同的语法调用远程对象。RMI API提供的类和方法可以处理所有访问远程方法的基础通信和参数引用要求的串行化。 使用RMI开发步骤： 1、定义一个远程接口（远程接口必须继承接口，每个方法必须抛出远程异常，方法参数和方法返回值都必须是可序列化的） 2、实现远程接口 3、定义使用远程对象的客户程序 4、产生远程访问对象的桩和框 5、注册远程对象 6、运行服务器和客户程序
    ---------------------------------------------------------------------------------
    ```

79. RMI体系结构的基本原则是什么？

    ```java
    RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。
    ----------------------------------------------------------------------------------
    定义行为和实现行为相分离。远程方法调用是javaAPI为远程调用提供的接口。允许运行在一台虚拟机上的对象远程访问另一台虚拟机的对象的方法，实现应用程序在网络上的分布式计算。客户机可以像调用本地方法一样调用远程对象的方法。
    ```

80. RMI体系结构分哪几层？

    ```java
    RMI体系结构分以下几层：
    存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。
    远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。
    传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。
    ```

    ![img](https://i.loli.net/2021/05/21/KTXia9PkDVs1p82.jpg)

81. RMI中的远程接口(Remote Interface)扮演了什么样的角色？

    ```java
    远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。
    ```

82. java.rmi.Naming类扮演了什么样的角色？

    ```java
    java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。
    ```

    ![image-20210521190218611](https://i.loli.net/2021/05/21/iDX4afPSlLAdeVm.png)

    

83. RMI的绑定(Binding)是什么意思？

    ```java
    绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。
    ----------------------------------------------------------------------------------
    RMI的绑定就是将一个对象赋给一个URI,让客户端可以通过这个URI访问该对象.
    服务端绑定:
    Naming.rebind("//localhost/MyServer", new ServerOperation());
    客户端根据绑定的URI获取服务端的对象:
    look_up = (RMIInterface) Naming.lookup("//localhost/MyServer");
    ```

84. Naming类的bind()和rebind()方法有什么区别？

    ```java
    bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。
    ---------------------------------------------------------------------------------
    bind(String name,Object obj)：注册对象，把对象与一个名字name绑定，这里的name其实就是URL格式。如果该名字已经与其它对象绑定，就会抛出NameAlreadyBoundException。
    
    rebind(String name,Object obj)：注册对象，把对象与一个名字绑定。如果该名字已经与其它对象绑定，不会抛出NameAlreadyBoundException，而是把当前参数obj指定的对象覆盖原先的对象。
    ```

85. 让RMI程序能正确运行有哪些步骤？

    ```java
    为了让RMI程序能正确运行必须要包含以下几个步骤：
    (1)编译所有的源文件。
    (2)使用rmic生成stub。
    (3)启动rmiregistry。
    (4)启动RMI服务器。
    (5)运行客户端程序。
    ```

86. RMI的stub扮演了什么样的角色？

    ```java
    远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤：
    (1)初始化到包含了远程对象的JVM的连接。
    (2)序列化参数到远程的JVM。
    (3)等待方法调用和执行的结果。
    (4)反序列化返回的值或者是方法没有执行成功情况下的异常。
    (5)把值返回给调用者。
    ```

87. 什么是分布式垃圾回收(DGC)？它是如何工作的？

    ```java
    DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。
    ---------------------------------------------------------------------------------
    RMI 子系统实现基于引用计数的“分布式垃圾回收”(DGC)，以便为远程服务器对象提供自动内存管理设施。
    当客户机创建（序列化）远程引用时，会在服务器端 DGC 上调用 dirty()。当客户机完成远程引用后，它会调用对应的 clean() 方法。
    针对远程对象的引用由持有该引用的客户机租用一段时间。租期从收到 dirty() 调用开始。在此类租约到期之前，客户机必须通过对远程引用额外调用 dirty() 来更新租约。如果客户机不在租约到期前进行续签，那么分布式垃圾收集器会假设客户机不再引用远程对象。
    ---------------------------------------------------------------------------------
    概念：
        1)Java虚拟机中，一个远程对象不仅会被本地虚拟机内的变量引用，还会被远程引用。
        2)只有当一个远程对象不受到任何本地引用和远程引用，这个远程对象才会结束生命周期。    
    说明：
        1)服务端的一个远程对象在3个地方被引用：
            1>服务端的一个本地对象持有它的本地引用
            2>服务端的远程对象已经注册到rmiregistry注册表中，也就是说，rmiregistry注册表持有它的远程引用。
            3>客户端获得远程对象的存根对象，也就是说，客户端持有它的远程引用。
        2)服务端判断客户端是否持有远程对象引用的方法：
            1>当客户端获得一个服务端的远程对象的存根时，就会向服务器发送一条租约(lease)通知，以告诉服务器自己持有了这个远程对象的引用了。
            2>客户端定期地向服务器发送租约通知，以保证服务器始终都知道客户端一直持有着远程对象的引用。
            3>租约是有期限的，如果租约到期了，服务器则认为客户端已经不再持有远程对象的引用了。
    ```

88. RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？

    ```java
    RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。
    ```

89. 解释下Marshalling和demarshalling。

    ```java
    当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。
    ---------------------------------------------------------------------------------
    marshalling跟serialization的本质都是序列化，二者的区别如下：（整理自StackOverflow高赞回答）
    Serialization的主要目的：传输对象、对象持久化；Marshalling的目的：远程传输参数(RMI的时候)
    那么比较二者在RMI这个语境中的差别：    
    Serialization：serialize对象的时候，只会将该对象内部数据写进字节流。         
    Marshalling：serialize对象的时候，除了对象内部数据，还会包含一些codebase信息（比如实现该对象的代码位置信息等）
    所以二者的关系可以理解为：Serialization是Marshallling的一部分。
    ```

90. 解释下Serialization和Deserialization。

    ```java
    Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。
    ---------------------------------------------------------------------------------
    序列化，实现序列化和反序列化的对象必须实现serializable接口，序列化是将对象变成字节流，存储到磁盘或网络。反序列化是序列化的反过程。
    ---------------------------------------------------------------------------------
    序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。 序列化:序列化是将对象转换为容易传输的格式的过程。例如，可以序列化一个对象，然后使用 HTTP 通过 Internet 在客户端和服务器之间传输该对象。在另一端，反序列化将从该流重新构造对象。 是对象永久化的一种机制。 确切的说应该是对象的序列化，一般程序在运行时，产生对象，这些对象随着程序的停止运行而消失，但如果我们想把某些对象（因为是对象，所以有各自不同的特性）保存下来，在程序终止运行后，这些对象仍然存在，可以在程序再次运行时读取这些对象的值，或者在其他程序中利用这些保存下来的对象。这种情况下就要用到对象的序列化。 对象序列化的最主要的用处就是在传递,和保存对象(object)的时候,保证对象的完整性和可传递性。譬如通过网络传输,或者把一个对象保存成一个文件的时候,要实现序列化接口
    ```

91. 什么是Servlet？

    ```java
    Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。
    -------------------------------------------------------------------------------
    servlet是基于java语言的web服务器端编程技术，是sun提供的一种实现***页的解决方案。servlet是运行在servlet容器中的java类，它能处理客户端的http请求并产生http响应。
    -------------------------------------------------------------------------------
    Servlet：1.处理客户端请求（表单提交的信息等）2.产生***页内容
    使用过程：初始化——service（分析客户端请求,比如是get还是post）——销毁，一个Servlet实例只会创建一次，重复调用的只是service过程。
    --------------------------------------------------------------------------------
    Servlet是使用Java Servlet接口运行在Web应用服务器上的Java程序，与普通Java程序不同的是它位于Web服务器内部的服务器端的Java应用程序，可以对Web浏览器或者其他HTTP客户端程序发送的请求进行处理
    ```

92. 说一下Servlet的体系结构。

    ```java
    所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。
    ---------------------------------------------------------------------------------
    Servlet类 ← GenericServlet类 ← HttpServlet类 ← MyServlet类(自己建的类)  （←代表继承）。
    Servlet类包含所需的三个必要的生命周期方法：init()初试化Servlet、service()相应Servlet请求、destroy()销毁Servlet，但直接继承需要重写所有方法，所以GenericServlet类继承了Servlet类并实现了所有方法，但它不是HTTP协议类，所以又由HttpServlet类继承GenericServlet类并是HTTP协议类。
    所以我们在建立Servlet类时只需继承HttpServlet类，重写我们需要的doGet()，doPost()请求即可，这两个方法对应客户端的get和post请求。
    ```

93. Applet和Servlet有什么区别？

    ```java
    Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。
    ---------------------------------------------------------------------------------
    applet是客户端的程序,它们可以直接嵌入到网页或者其他特定的容器中，并能够产生特殊的效果。 
    servlet是服务端器的程序,用于实现服务器功能的扩充,响应客户端请求.
    ```

94. GenericServlet和HttpServlet有什么区别？

    ```java
    GenericServlet类实现了Servlet和ServletConfig接口。实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承GenericServlet类来简化程序的代码，但需要实现service()方法。
    HttpServlet类继承了GeneriServlet类，为实际开发中大多数用Servlet处理 HTTP请求的应用灵活的方法。
    ```

95. 解释下Servlet的生命周期。

    ```java
    对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet(译者注：这里应该是Servlet而不是server)的destroy()方法把Servlet删除掉。
    --------------------------------------------------------------------------------
    Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：
    ①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。
    ②装载并创建该Servlet的一个实例对象。 
    ③调用Servlet实例对象的init()方法。
    ④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。
    ⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。
    ```

96. doGet()方法和doPost()方法有什么区别？

    ```java
    doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。
    doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。
    ----------------------------------------------------------------------------------
    doGet：路径传参。效率高，安全性差
    doPOST：实体传参。效率低，安全性好
    ----------------------------------------------------------------------------------
    ```

97. 什么是Web应用程序？

    ```java
    web应用程序就是一种可以通过web进行访问的应用程序，简单的说就是可以直接通过浏览器进行访问的应用程序。基于典型的B/S模式的应用程序，核心是对数据库的相关操作和处理.
    ----------------------------------------------------------------------------------
    Web应用程序是一种可以通过Web访问的应用程序。Web应用程序的一个最大好处是用户很容易访问应用程序。用户只需要有浏览器即可，不需要再安装其他软件。一个Web应用程序是由完成特定任务的各种Web组件（web components)构成的并通过Web将服务展示给外界。在实际应用中，Web应用程序是由多个Servlet、JSP页面、HTML文件以及图像文件等组成。所有这些组件相互协调为用户提供一组完整的服务。
    ```

98. 什么是服务端包含(Server Side Include)？

    ```java
    服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签.
    ---------------------------------------------------------------------------------
    英文简称为SSI。是在页面被提供时由服务器端进行运算，以对现有html页面增加动态生成的内容；如果增加的动态内容少，就用SSI，如果整个页面大多数都需要动态加载，则可以使用cgi提供整个页面，或者使用其他的动态技术。
    ```

99. 什么是Servlet链(Servlet Chaining)？

    ```java
    Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。
    ----------------------------------------------------------------------------------
    servlet链接提供了将一个servlet的输出重定向为另一个servlet的输入的能力。这样，你就可以划分工作，从而使用一系列servlet来实现它。另外，你还可以将servlet组织在一起以提供新的功能。
    ```

100. 如何知道是哪一个客户端的机器正在请求你的Servlet？

     ```java
     ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。
     ---------------------------------------------------------------------------------
     request.getRemoteAddr();//ipaddr
     request.getRemoteHost();//主机名
     request.getRequestURL();//返回全路径
     request.getRequestURI();//返回除去host（域名或者ip）部分的路径
     request.getContextPath();//返回工程名部分，如果工程映射为/，此处返回则为空
     request.getServletPath();//返回除去host和工程名部分的路径
     ```

101. HTTP响应的结构是怎么样的？

     ```java
     HTTP响应由三个部分组成：
     状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。
     HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。
     主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。
     ```

102. 什么是cookie？session和cookie有什么区别？

     ```java
     cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：
     无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。
     在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。
     ----------------------------------------------------------------------------------
     cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户的状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和cookie一同给服务器。服务器检查该cookie，从而判断用户的状态。服务器还可以根据需要修改cookie的内容。 session是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。 如果说cookie机制是通过检查客户身上的“通信证”，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。
     
     session比cookie安全，别人可以分析存放在本地的cookie并进行cookie欺骗.
     ```

103. 浏览器和Servlet通信使用的是什么协议？

     ```
     浏览器和Servlet通信使用的是HTTP协议。
     http和https协议有什么区别？
     ```

102. 什么是HTTP隧道？

     ```java
     HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。
     ----------------------------------------------------------------------------------
     
     ```

103. sendRedirect()和forward()方法有什么区别？

     ```java
     sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。
     ---------------------------------------------------------------------------------
     forward是服务器内部的跳转，浏览器的地址栏不会发生变化，同时可以把request和response传递给后一个请求。sendRedirect()是浏览器方面的跳转，要发送两次请求，地址栏也会发生变化，同时request和response也会发生变化，重新生成新的对象。
     ---------------------------------------------------------------------------------
     假设当前页面是login.jsp页面，点击某个按钮触发了浏览器请求，浏览器请求服务器调用sendRedict(“exit.jsp”);
     第一次请求是在login.jsp页面，浏览器向服务器请求调用sendRedict(“exit.jsp”)，服务器在响应头中返回exit.jsp的完整路径，然后显示在浏览器url栏上。
     第二次请求就是浏览器请求访问exit.jps页面。
     ```

104. 什么是URL编码和URL解码？

     ```java
     URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。
     ---------------------------------------------------------------------------------
     URL编码指的是对网址上的不安全的字符，例如中文，进行编码，编码后的中文方便在网络上传输。
     可以使用URLEncoder.encoder(String url,String encoder)方法进行url编码;
     使用URLDecoder.decode(String url,String encoder)方法是进行URL解码
     ```

105. 什么是JSP页面？

     ```java
     jsp是java开发的专门用于动态显示页面的技术。jsp编译时，会首先编译成servlet文件，然后编译成class文件。包含9大内置对象：response、request、exception、out、application、pagecontext、config、session、page。有四个域对象：request、pagecontext、session、application
     ---------------------------------------------------------------------------------
     JSP 全称是 Java Server Pages ，它和 servle 技术一样，都是 SUN 公司定义的一种用于开发动态 web 资源的技术。 JSP 实际上就是 Servlet 。（jsp = html + java）
     html: 静态内容
     servlet ：服务器端的小应用程序。适合编写 java 逻辑代码，如果编写网页内容 -- 苦逼。
     jsp: 适合编写输出动态内容，但不适合编写 java 逻辑
     ```

106. JSP请求是如何被处理的？

     ```java
     客户端通过浏览器发送jsp请求，服务器端接受到请求后，判断是否是第一次请求该页面，或者该页面是否改变，若是，服务器将jsp页面翻译为servlet，jvm将servlet编译为.class文件，字节码文件加载到服务器内存上执行，服务器将处理结果以.html页面的形式返回给客户端，若该页面不是第一次请求，则省略翻译和编译的步骤，直接执行。
     ```

107. JSP有什么优点？

     ```java
     下面列出了使用JSP的优点：
     JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。
     JSP页面可以被预编译。
     JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。
     开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。
     开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。
     ----------------------------------------------------------------------------------
     1.JSP代码跨平台, 即一次编写,处处运行 
     众所周知,由于微软的垄断性,它的产品可移植性做得十分差,ASP也不例外, 
     2.JSP组件跨平台 
     JSP组件(企业JavaBeans,JavaBeans或定制的JSP标签)都是跨平台可重用的.企业JavaBeans组件可以访问传统的数据库,并能以分布式系统模式工作于Solaris,Linux,UNIX和Windows平台. 
     3.支持多种网页格式 
     目前, JSP技术支持的网页格式还没有一个明确的标准.一般来说,JSP技术既可以支持HTML/DHTML的传统浏览器文件格式,又可以支持应用于无线通信设备如移动电话,PDA等设备进行网页预览的WML文件格式,还可以支持其他一些B2B电子商务网站应用的XML格式. 
     4.JSP标签可扩充性 
     尽管ASP和JSP都使用标签与脚本技术来制作动态Web网页,JSP技术允许开发者扩展JSP标签,定制JSP标签库,所以网页制作者充分利用与XML兼容的标签技术强大的功能,大大减少对脚本语言的依赖.由于定制标签技术,使网页制作者降低了制作网页的复杂度. 
     5.健壮性与安全性 
     由于JSP页面使用的脚本语言是java语言, 因此,它就具有java技术的所有好处, 包括健壮的存储管理和安全性。
     ```

108. 什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？

     ```java
     Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在 <%@ 和 %>之间的。下面列出了不同类型的Directive：
     包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。
     页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。
     Taglib指令： 用来声明页面中使用的自定义的标签库。
     ---------------------------------------------------------------------------------
     
     ```

109. 什么是JSP动作(JSP action)？

     ```java
     JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：
     jsp:include-当JSP页面被请求的时候包含一个文件。
     jsp:useBean-找出或者是初始化Javabean。
     jsp:setProperty-设置JavaBean的属性。
     jsp:getProperty-获取JavaBean的属性。
     jsp:forward-把请求转发到新的页面。
     jsp:plugin-产生特定浏览器的代码。
     ```

110. 什么是Scriptlets？

     ```java
     JSP技术中，scriptlet是嵌入在JSP页面中的一段Java代码。scriptlet是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的scriplet。
     ---------------------------------------------------------------------------------
     指jsp页面里 <%    %> 中间的代码。
     一个包含任何在JSP页面中合法的脚本语言的代码片断的JSP脚本元素。Java Web开发时，尽量不要在JSP中出现这种Scriptlets，尽量多使用JSP标签，或者JSTL，或者一些框架的标签。
     ```

111. 声明(Decalaration)在哪里？

     ```java
     声明跟Java中的变量声明很相似，它用来声明随后要被表达式或者scriptlet使用的变量。添加的声明必须要用开始和结束标签包起来。
     ----------------------------------------------------------------------------------
     
     ```

     ![image-20210521214511333](https://i.loli.net/2021/05/21/xQB7gspElCRo9OA.png)

112. 什么是表达式(Expression)？

     ```java
     一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。
     由于表达式的值会被转化成String，所以您可以在一个文本行中使用表达式而不用去管它是否是HTML标签。
     表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用分号来结束表达式。
     
     JSP表达式的语法格式：
         <%= 表达式 %>
     同样，您也可以编写与之等价的XML语句：
         <jsp:expression> 表达式 </jsp:expression>
     程序示例：
         <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%> <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>菜鸟教程(runoob.com)</title> </head> <body> <p> 今天的日期是: <%= (new java.util.Date()).toLocaleString()%> </p> </body> </html> 
     运行后得到以下结果：
         今天的日期是: 2016-6-25 13:40:07
     ---------------------------------------------------------------------------------
     表达式是由一个或多个操作数通过运算符组合而成。最简单的表达式仅由一个运算符和一个操作数构成，较复杂的表达式则由多个运算符以及多个操作数构成。表达式的计算结果为一个值，如果是逻辑运算表达式，其计算结果为逻辑值结果，即真或假，在java编程中，逻辑值为boolean类型。
     ```

113. 隐含对象是什么意思？有哪些隐含对象？

     ```java
     JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象：
     
     九大隐含对象：
     page:表示当前jsp页面的一个实例，它的类型是java.lang.Object，可以用this代替；
     out:JspWriter out = pageContext.getOut()  用于标签对象中输出
     request：HttpServletRequest接口的简单实用；
     response：HttpServletResponse接口的简单使用；
     session；HttpSession简单使用；
     application:ServletContext的简单使用；
     config：ServletConfig类，在jsp中很少使用；
     exception：jsp页面发生错误的时候，会自动产生此对象；
     pageContext；表示当前页面容器，可以访问当前页面的所有对象；
     --------------------------------------------------------------------------------
     JSP隐含对象就是在编译成servlet时，servlet里产生的可以直接用的内置对象
     ```

114. 面向对象软件开发的优点有哪些？

     ```java
     代码开发模块化，更易维护和修改。
     代码复用。
     增强代码的可靠性和灵活性。
     增加代码的可理解性。
     面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。
     ```

115. 封装的定义和好处有哪些？

     ```java
     封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。
     下面列出了使用封装的一些好处：
     通过隐藏对象的属性来保护对象内部的状态。
     提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。
     禁止对象之间的不良交互提高模块化。
     参考这个文档获取更多关于封装的细节和示例。
     ```

116. 多态的定义？

     ```java
     多态：相同类型的引用变量，调用同一个方法时呈现出多种不同的行为特征。
     对象的实例变量不具备多态性。
     Java引用变量有两个类型：编译时类型，运行时类型
     编译时类型由声明该变量时使用的类型决定
     运行时类型由实际赋给该变量的对象决定
     如果编译时类型和运行时类型不一致，就可能出现多态（Polymorphism）
     
     ---------------------------------------------------------------------------------
     多态：同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作
     
     多态的优点：
     1. 消除类型之间的耦合关系
     2. 可替换性
     3. 可扩充性
     4. 接口性
     5. 灵活性
     6. 简化性
     
     多态存在的三个必要条件：
     继承
     重写
     父类引用指向子类对象
     比如：Animal am = new Dog();
     当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法
     ```

117. 继承的定义？

     ```java
     继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用性，也可以在不修改类的情况下给现存的类添加新特性。
     ----------------------------------------------------------------------------------
     提供一种让某个类型的对象获得另一个类型的对象的属性的方法，目的是代码重用
     ----------------------------------------------------------------------------------
     继承是一种类与类之间的关系
     利用一个已经存在的类，快速的创建新的类的机制
     被继承的类称为父类/超类，继承者称为子类（得到继承的类为子类）
     子类继承父类，拥有父类所有属性和方法
     ```

118. 抽象的定义？抽象和封装的不同点？

     ```java
     抽象：就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。抽象包括两个方面：一个是数据抽象，一个是过程抽象。数据抽象也就是对象的属性。过程抽象是对象的行为特征。
     封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。封装分为属性的封装和方法的封装。
     ----------------------------------------------------------------------------------
     抽象，是指从众多的事务中抽取出具有共同的、本质性的特征作为一个整体。是共同特质的集合形式。   封装，是将通过抽象所得到的数据信息和操作进行结合，使其形成一个有机的整体。对内执行操作，对外隐藏细节和数据信息。 
     两者的区别，在于抽象是一种思维方式，而封装则是一种基于抽象性的操作方法。我们通过抽象所得到数据信息及其功能，以封装的技术将其重新聚合，形成一个新的聚合体，也就是类。或者说，两者是合作者的关系，如果没有抽象，封装就无从谈起，如果没有封装，抽象也将没有意义。 
     ```

     

